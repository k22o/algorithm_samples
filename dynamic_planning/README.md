# 動的計画法

- knapsack_01_basic.cpp
    - 最も基本的な，ナップサックの動的計画法
    - dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[j]]+v[j])
    - メモリを少なくするためのバージョンも
- knapsack_01_ver2.cpp
    - ナップサックの動的計画法,ループ3回
- knapsack_01_bool.cpp
    - ナップサックの動的計画法,boolをDPの値にする
- knapsack_01_inverse.cpp
    - メモリを少なくするための方法
    - ある重みまでの価値の最大化->ある価値まででの重みの最小化
- knapsack_nonLimitNum.cpp
    - 1種類の商品をいくらでも詰められるナップサック問題
    - dp[i][j] = max(dp[i-1][j],dp[i][j-w[i]]+v[i])

- digit_DP.cpp
    - 桁DP
- longest_common_subsequence.cpp
    - 最長共通文字列問題．2変数の動的計画法．
- levenshtein_distance.cpp
    - 編集距離の解き方
- partial_sum_problem.cpp
    - 部分和問題(いくつかの数を選んでNにできるか)
    - DPの値にbool以上の判定要素を書き込んでいく
- LIS.cpp
    - 最小増加部分列問題．2次元DPを用いず，
    - 1次元配列と二分探索により，O(NlogN)での計算が可能．
- inteval_dp.cpp
    - 区間DP．数列や文字列を内部から削除していく場合などに利用(O(N^3))．
- tree_dp.cpp
    - 木構造を利用したDP.
- bitDP_topological_sort.cpp
    - N!の場合分けが必要な場合，2^Nでdpすることで計算量を落とす
    - 有向非巡回グラフ(DAG)のノードを順序付けし，値に応じて並べ替える．